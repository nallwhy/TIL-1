# Dividd & Conquer (분할 정복)

- 주어진 문제를 둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산해냄
- 분할 정복이 일반적인 재귀 호출과 다른 점은 문제를 한 조각과 나머지 전체로 나누는 대신 거의 같은 크기의 부분 문제로 나눔
- 문제를 둘 이상 부분 문제로 나누는 자연스러운 방법과, 부분 문제의 답을 조합해 원래 문제의 답을 계산하는 효율적인 방법이 있어야 분할 정복을 적용해 문제를 해결할 수 있음
- 같은 작업을 더 빠르게 처리해줌

구성 요소

- Divide: 문제를 더 작은 문제로 분할하는 과정
- Merge: 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정
- Base case: 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제

### 예제: 수열의 빠른 합과 행렬의 빠른 제곱

1부터 n까지의 합 구하기

`fastSum() = 1 + 2 + ... + n = (1 + 2+ ... + n/2) + ((n/2 + 1) + ... + n)`

첫 번째 부분 문제는 fastSum(n/2)로 나타낼 수 있지만, 두 번째 부분 문제는 그렇지 않기에 문제를 재귀적으로 풀기 위해서는 각 부분 문제를 1부터 n까지의 합 꼴로 표현해야 함

`(n/2 + 1) + ... + n = (n/2 + 1) + (n/2 + 2) + ... + (n/2 + n/2) = n/2 * n/2 + (1 + 2 + 3 + ... + n/2) = n/2 * n/2 + fastSum(n/2)`

따라서 다음과 같이 정리할 수 있음:

`fastSum(n) = 2 * fastSum(n/2) + n^2/4 (n이 짝수일 때)`

```c++
int fastSum(int n) {
	// base case
	if(n == 1) return 1;
	if(n % 2 == 1) return fastSum(n-1) + n;
	return 2 * fastSum(n/2) + (n/2) * (n/2);
}
```

### 시간 복잡도 분석

fastSum()과 recursiveSum() 둘 다 내부에 반복문이 없는 함수이므로, 순전히 함수가 호출되는 횟수에 비례함. recursvieSum()의 경우 n번의 함수 호출이 필요하지만, fastSum()은 호출될 때마다 최소한 두 번에 한 번 꼴로 n이 절반으로 줄어듬.

fastSum() 재귀 호출의 입력이 어떻게 변화하는지 이진수로 살펴보면, n의 이진수 표현의 마지막 자리가 1이면 0으로 바뀌고, 마지막 자리가 0이면 끝자리가 없어짐. 따라서 fastSum()의 총 호출 횟수는 n의 이진수 표현의 자리수+첫 자리를 제외하고 나타나는 1의 개수. 두 값의 상한은 모두 lg(n)이므로 이 알고리즘의 실행 시간은 `O(lg(n))`

### 행렬의 거듭제곱

행렬의 곱셈은 `O(n^3)`의 시간이 들음. 

```c++
class SquareMatrix;
SquareMatrix identity(int n);
SquareMatrix pow(const SquareMatrix& A, int m) {
	// base case
	if(m == 0) return identity(A.size());
	if(m % 2 > 0) return pow(A, m-1) * A;
	SquareMatrix half = pow(A, m/2);
	return half * half;
}
```

### 나누어 떨어지지 않을 때의 분할과 시간 복잡도

m이 홀수일 때, A^m=A*A^(m-1)로 나누지 않고, 좀더 절반에 가깝게 나누는게 좋지 않을까 생각할 수 있지만, 실제로는 A^m을 찾기 위해 계산해야 할 부분 문제의 수가 늘어남.

### Merge sort(병합 정렬)과 Quick sort(퀵 정렬)

병합 정렬

- 주어진 수열을 가운데에서 쪼개 비슷한 크기의 수열 두 개로 만든 뒤 이들을 재귀 호출을 이용해 각각 정렬. 정렬된 배열을 하나로 합침으로써 정렬된 전체 수열을 얻음
- O(nlg(n))

퀵 정렬

- 한쪽의 배열에 포함된 수가 다른 쪽 배열의 수보다 항상 작도록 배열을 분할. 이는 배열에 있는 수 중 임의의 기준 수를 지정한 후 기준보다 작거나 같은 숫자를 왼쪽, 더 큰 숫자를 오른쪽으로 보내는 과정
- 최악: O(n^2), 평균: O(nlg(n))

### 예제: 카라츠바의 빠른 곱셈 알고리즘




